from Cryptodome.Util.number import getPrime, long_to_bytes
from gmpy2 import iroot
import sympy
e = 3

#do e nho nen ta ko co tinh chat modul 
# cipher = plain^e
#ta can tim plain= can bac e cua cipher
n=17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

p = getPrime(1024)
q = getPrime(1024)
phi = (p - 1) * (q - 1)
print(long_to_bytes(iroot(ct,e)[0]))

#assert p*q==n
# cach 2 su dung Newton-Raphson để tính căn bậc k của số n.
def iroot2(n, k):
    # Khởi tạo giá trị ban đầu cho căn bậc k của n
    x_prev = n
    x_next = (1 + n) // k

    # Tiến hành tính toán theo phương pháp Newton-Raphson
    while x_next < x_prev:
        x_prev = x_next
        x_next = ((k - 1) * x_prev + n // pow(x_prev, k-1)) // k

    # Làm tròn kết quả đến số nguyên gần nhất
    return int(x_prev)


result = iroot2(ct, 3)
print("Result: ",long_to_bytes (result))  
